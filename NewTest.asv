ImaSrc = imread('Image\coin4.jpg');
Imagray = rgb2gray(ImaSrc);
Imadb = im2double(Imagray);
T0 = 0.01;
T1 = (min(Imadb(:)) + max(Imadb(:)))/2;
r1 = find(Imadb > T1);
r2 = find(Imadb <= T1);
T2 = (mean(Imadb(r1)) + mean(Imadb(r2)))/2;
while abs(T2 -T1) < T0
    T1 = T2;
    r1 = find(Imadb > T1);
    r2 = find(Imadb <= T1);
    T2 = (mean(Imadb(r1)) + mean(Imadb(r2)))/2;
end

Imaim2bw = imbinarize(Imadb, T2);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Imafil1 = [-1, -1, -1; 2, 2, 2; -1 -1 -1];
% Imafil2 = [-1, -1, 2; -1, 2, -1; 2, -1, -1];
% Imafil3 = [-1, 2, -1; -1, 2, -1;-1, 2, -1];
% Imafil4 = [2, -1, -1; -1, 2, -1; -1, -1, 2];
% 
% Imagf1 = imfilter(Imagray, Imafil1);
% Imagf2 = imfilter(Imagray, Imafil2);
% Imagf3 = imfilter(Imagray, Imafil3);
% Imagf4 = imfilter(Imagray, Imafil4);
% Imagf = Imagf1+Imagf2+Imagf3+Imagf4; 

figure;imshow(ImaSrc);
% subplot(142), imshow(Imagf);
figure;imshow(Imaim2bw);

% 二值化图像（可以使用适当的阈值或其他方法）
binaryImage = imbinarize(Imagray);

% 定义开运算的结构元素
se = strel('disk',32);  % 这里使用了一个半径为5的圆形结构元素，你可以根据需要调整大小

% 应用开运算
openedImage = imopen(binaryImage, se);

% 显示结果
%figure;
%subplot(1,4,1), imshow(binaryImage), title('二值图像');

sigma=8;                                  % 标准差大小  
window=double(uint8(3*sigma)*2+1);        % 窗口大小一半为3*sigma  
H=fspecial('gaussian', window, sigma);    % fspecial('gaussian', hsize, sigma)产生滤波模板   

Imagausf = openedImage;
LoopNum = 0;
while LoopNum < 9
    Imagausf = imfilter(Imagausf,H,'replicate');
    LoopNum = LoopNum + 1;
end
figure;imshow(Imagausmed), title('开运算后的二值图像');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 标记连通域
[labeledImage,coiNum] = bwlabel(~Imagausf, 4);

Imafil1 = [-1, -1, -1; 2, 2, 2; -1 -1 -1];
Imafil2 = [-1, -1, 2; -1, 2, -1; 2, -1, -1];
Imafil3 = [-1, 2, -1; -1, 2, -1;-1, 2, -1];
Imafil4 = [2, -1, -1; -1, 2, -1; -1, -1, 2];

Imagf1 = imfilter(labeledImage, Imafil1);
Imagf2 = imfilter(labeledImage, Imafil2);
Imagf3 = imfilter(labeledImage, Imafil3);
Imagf4 = imfilter(labeledImage, Imafil4);
Imagf = Imagf1+Imagf2+Imagf3+Imagf4; 
figure;imshow(Imagf);

% 显示标记结果
figure;imshow(label2rgb(labeledImage));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

[circlefind]


function[circlefind]=findcircle(img,minr,maxr,stepr,stepa,percent)
    r=round((maxr-minr)/stepr)+1;%可增长的步长个数
    angle=round(2*pi/stepa);
    [m,n]=size(img);
    houghspace=zeros(m,n,r);%霍夫空间
    [m1,n1]=find(img);%返回二值化边缘检测图像Img中非零点的坐标，m1存放横坐标，n1存放纵坐标
    circleNum=size(m1,1);%非零点个数
    %霍夫空间，统计相同圆 点的个数
    %a = x-r*cos(angle), b = y-r*sin(angle)
    for i=1:circleNum
        for j=1:r
            for k=1:angle
                a=round(m1(i)-(minr+(j-1)*stepr)*cos(k*stepa));
                b=round(n1(i)-(minr+(j-1)*stepr)*sin(k*stepa));
                if(a>0&&a<=m&&b>0&&b<=n)
                    houghspace(a,b,j)=houghspace(a,b,j)+1;
                end
            end
        end
    end
    %以阈值来检测圆
    par=max(max(max(houghspace)));%找出个数最多的圆的数量作为阈值
    par2=par*percent;%百分比percent阈值调整
    [m2,n2,r2]=size(houghspace);
    circlefind=[];%存储大于阈值的圆的圆心坐标及半径
    for i=1:m2
        for j=1:n2
            for k=1:r2
                if (houghspace(i,j,k)>=par2)
                    a=[i,j,minr+k*stepr];
                    circlefind=[circlefind;a];
                end
            end
        end
    end
end
